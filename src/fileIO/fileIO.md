# 文件操作知识点详解

## 1. 文件打开方式：阻塞与非阻塞

### 主要区别
当 I/O 操作不能立即完成时的行为差异：
- **阻塞方式**：
  - I/O 操作无法立即完成时，操作系统会挂起程序/线程
  - 单线程：直接挂起整个程序
  - 多线程：挂起对应的线程
  - I/O 操作可完成时自动唤醒程序/线程

- **非阻塞方式** (使用 `O_NONBLOCK` 标志开启)：
  - I/O 操作无法立即完成时，系统直接返回错误
  - 返回值：`-1`
  - 错误码：`errno` 设置为 `EAGAIN` 或 `EWOULDBLOCK`

### 应用场景
| **模式** | **优点** | **缺点** | **适用场景** |
|----------|----------|----------|--------------|
| **阻塞模式** | 编程简单，系统自动处理等待 | 可能造成程序/线程长时间等待 | 简单应用，不需要精细控制I/O |
| **非阻塞模式** | 可自定义失败处理逻辑，提高程序响应性 | 需要手动处理重试逻辑 | 高性能服务器、实时系统、需要自定义重试策略的场景 |

> **设计考虑**：非阻塞模式允许开发者实现自定义的重试策略（如指数退避算法）、超时机制或并行处理其他任务，从而提高程序的灵活性和性能。

## 2. 文件同步标志：O_SYNC, O_DSYNC 和 O_RSYNC

### 元数据概念
文件元数据包含：
- **标识信息**：文件名、路径、唯一ID
- **描述信息**：文件类型、大小、格式
- **上下文信息**：创建者、时间戳、位置
- **管理信息**：权限、属性、状态
- **关系信息**：链接、依赖、版本

### 标志位区别
| **标志位** | **写入行为** | **同步范围** | **性能影响** |
|------------|--------------|--------------|--------------|
| **O_SYNC** | 等待所有写入操作完成才返回 | 文件内容 + **完整元数据** | 高延迟（最安全） |
| **O_DSYNC** | 只确保数据写入完成 | 文件内容 + **关键元数据**（如文件大小） | 中等延迟 |
| **O_RSYNC** | **需与其他标志组合使用** | 读取前刷新挂起的写入 | 额外延迟 |

### 组合使用
```c
// 读取前刷新所有挂起的写入（最全面）
int fd = open("file", O_RDWR | O_SYNC | O_RSYNC);

// 读取前只刷新数据写入（高效选择）
int fd = open("file", O_RDWR | O_DSYNC | O_RSYNC);
```

## 3. creat 函数特性
```c
// creat 等效于以下 open 调用
int fd = creat("file.txt", mode);
// 等价于 ↓
int fd = open("file.txt", O_WRONLY | O_CREAT | O_TRUNC, mode);
```

### 关键限制：
- 仅支持**只写模式**（`O_WRONLY`）
- 创建文件时会**清空现有内容**（`O_TRUNC`）
- **无法读取**已创建的文件

## 4. 文件名截断行为

### 系统差异
| **系统行为** | 文件名超长时 | 检查方法 | 潜在风险 |
|--------------|--------------|----------|----------|
| **截断系统** | 自动缩短文件名 | `#ifdef _POSIX_NO_TRUNC` | 文件名信息丢失 |
| **非截断系统** | 返回 `ENAMETOOLONG` 错误 | `#ifdef _POSIX_NO_TRUNC` | 需要手动处理 |

### 示例说明
```c
// 检查系统截断行为
#ifdef _POSIX_NO_TRUNC
    // 系统不会截断文件名（返回错误）
#else
    // 系统会自动截断文件名（如限制14字符）
#endif
```

> **注意**：在截断系统中，长度为最大限制（如14字符）的文件名可能已被修改，无法确定原始完整名称。

### 最佳实践
- 始终检查文件名长度是否超出 `NAME_MAX` 限制
- 对关键系统使用 `_POSIX_NO_TRUNC` 宏进行条件编译
- 考虑使用现代文件系统（如EXT4/XFS）避免截断问题

一句话：  
`dup` 和 `dup2` 都是 **“克隆”一个已经打开的文件描述符**，让你得到一个新的 fd，指向**同一个打开文件表项**（共享偏移量、状态标志等）。

----------------------------------------
1. 原型
```c
#include <unistd.h>

int dup(int oldfd);        /* 返回当前可用的最小 fd */
int dup2(int oldfd, int newfd);  /* 指定新的 fd 值 */
```

----------------------------------------
2. 它们到底做了什么？
- 内核维护一张“**打开文件表**”，每一项记录：
  - 当前文件偏移量  
  - 状态标志（`O_APPEND`, `O_SYNC`, …）  
  - 引用计数（多少个 fd 指向它）

- `dup(oldfd)`  
  复制 `oldfd`，返回**当前进程未使用的最小 fd**，同时把引用计数 +1。  
  例如：
  ```c
  int newfd = dup(1);   // newfd 可能是 3、4、5...
  write(newfd, "hello\n", 6);  // 与写到 stdout 效果一样
  ```

- `dup2(oldfd, newfd)`  
  **指定**新的 fd 数值为 `newfd`：  
  - 如果 `newfd` 已经打开，先把它 `close`（原子操作，不会短暂出现“空洞”）。  
  - 然后把 `newfd` 指向 `oldfd` 所指的文件表项。  
  - 返回值就是 `newfd`（成功时）。  

  经典用法：重定向
  ```c
  int fd = open("log.txt", O_WRONLY|O_CREAT|O_TRUNC, 0644);
  dup2(fd, 1);   // 把 stdout 重定向到 log.txt
  close(fd);
  printf("这条内容会写进 log.txt\n");
  ```

----------------------------------------
3. 对比总结

| 功能                | dup               | dup2                        |
|---------------------|-------------------|-----------------------------|
| 新 fd 数值          | 系统选最小可用    | 用户指定                    |
| 若 newfd 已打开     | 不适用            | 先 close 再复制             |
| 原子性              | —                 | 整个操作原子                |
| 常见用途            | 简单复制          | 重定向（stdin/stdout/stderr）|

----------------------------------------
4. 小陷阱
- `dup2(oldfd, oldfd)` 是合法的空操作，返回 `oldfd`。  
- 用完后记得 `close` 不再需要的 fd，否则会出现“**描述符泄漏**”。  
- 需要更大范围的 fd 复制/移动可用 `dup3`（Linux 特有，带 `flags`，可设 `O_CLOEXEC`）。

----------------------------------------
一句话记忆：  
`dup` 是“给我一个新的”；`dup2` 是“把旧的塞进指定编号里”。

`/dev/fd` 是一个 **伪文件系统**（多数 Linux 发行版上由 **devtmpfs** 里的 **proc 文件系统** 挂载的一个 **符号链接**），它把 **进程当前已经打开的文件描述符** 以“文件名”的方式暴露出来，让你可以用普通的 **路径语法** 去读写 **fd**。

一句话：  
**“把 0、1、2、3 … 这些整数描述符变成 /dev/fd/0、/dev/fd/1、/dev/fd/3 … 这样的文件名”**。

------------------------------------------------
1. 到底是什么
- 典型实现  
  ```
  $ ls -l /dev/fd
  lrwxrwxrwx 1 root root 13 Jun  5 10:20 /dev/fd -> /proc/self/fd
  ```
  也就是说 `/dev/fd` 只是指向 `/proc/self/fd` 的一个符号链接，而 `/proc/self/fd` 又是 **procfs** 的一个目录：  
  ```
  $ ls /proc/self/fd
  0  1  2  3
  ```
  这些“文件”其实是 **指向对应文件描述符的符号链接**。

- 你看到的文件名就是 **fd 的数字**。  
  ```
  $ echo hello > /dev/fd/1   # 把 hello 写到 stdout
  hello
  ```

------------------------------------------------
2. 常见用途
1. **shell 重定向**  
   经典 trick：把 **here-document** 重定向到 **grep** 等工具，而不用临时文件  
   ```bash
   grep foo /dev/fd/3 3<<EOF
   line1
   foo line
   EOF
   ```

2. **脚本里复用已打开的文件**  
   某些程序只接受“路径参数”，而你手里只有一个 fd，例如：
   ```bash
   exec 3< data.txt
   mytool --input /dev/fd/3
   ```

3. **调试/查看进程已打开的文件**  
   ```
   ls -l /proc/1234/fd
   ```

------------------------------------------------
3. 注意事项
- 只在 **Unix / Linux** 上有；macOS 也是同一个机制。  
- 读 `/dev/fd/N` 得到的内容就是 **该 fd 的当前偏移处** 的数据，和普通文件一样。  
- 因为是符号链接，所以 `readlink /dev/fd/0` 可以告诉你它具体指向哪个文件。  
- 对于 **未打开** 的 fd，访问 `/dev/fd/N` 会返回 `ENOENT`。

------------------------------------------------
一句话总结：  
`/dev/fd` 把“文件描述符”变成了“文件名”，让任何只能路径访问的程序也能用你已打开的 fd，本质是 **procfs 的一层符号链接包装**。